# 一般的なフローに従って処理
# スコープ選択→ターゲット選択→操作選択→(オプションターゲット)
pecorian() {
    # 配列に半角スペースを許す
    IFS_BACKUP=$IFS
    IFS=$'\n'

    # 1) select scope 
    local scope_current_dir="Current dir"
    local scope_current_dir_up3="Current dir up depth -3"
    local scope_current_dir_up2="Current dir up depth -2"
    local scope_current_dir_below2="Current dir below depth 2"
    local scope_current_dir_below3="Current dir below depth 3"
    local scope_current_dir_below_all="Current dir below depth all"
    local scope_favorite="Favorite"
    local scope_recent="Recently used"
    local scope_git_rep="Git repository(ghq)"

    local scope_list=()
    scope_list=(${scope_list[@]} $scope_current_dir)
    scope_list=(${scope_list[@]} $scope_current_dir_up3)
    scope_list=(${scope_list[@]} $scope_current_dir_up2)
    scope_list=(${scope_list[@]} $scope_current_dir_below2)
    scope_list=(${scope_list[@]} $scope_current_dir_below3)
    scope_list=(${scope_list[@]} $scope_current_dir_below_all)
    scope_list=(${scope_list[@]} $scope_favorite)
    scope_list=(${scope_list[@]} $scope_recent)
    scope_list=(${scope_list[@]} $scope_git_rep)
    
    local scope="$( for s in ${scope_list[@]}; do echo $s; done | peco )"

    # 2) select target
    # todo: 新規作成のフロー新規作成ファイル名を指定？？
    local target=""
    case $scope in
        $scope_current_dir)
            target="$( \ls -aF | peco )" # エイリアスを外して、ディレクトリは/をつけて表示(Fオプション)
            ;;
	$scope_current_dir_up3)
	    # findは難しい、http://takuya-1st.hatenablog.jp/entry/20110918/1316338219
	    # 自分自身のリストはlsで表示されるので不要
	    local current_dir="$(basename `pwd`)"
            target="$( find ../../ -maxdepth 3 -type d -name '.git' -prune -o -type d -name $current_dir -prune -o -print | peco )"
            ;;
	$scope_current_dir_up2)
	    # findは難しい、http://takuya-1st.hatenablog.jp/entry/20110918/1316338219
	    local current_dir="$(basename `pwd`)"
            target="$( find ../ -maxdepth 2 -type d -name '.git' -prune -o -type d -name $current_dir -prune -o -print | peco )"
            ;;
	$scope_current_dir_below2)
	    # findは難しい、http://takuya-1st.hatenablog.jp/entry/20110918/1316338219
            target="$( find . -maxdepth 2 -type d -name '.git' -prune -o -print | peco )"
            ;;
	$scope_current_dir_below3)
            target="$( find . -maxdepth 3 -type d -name '.git' -prune -o -print | peco )"
            ;;
	$scope_current_dir_below_all)
            target="$( find . -type d -name '.git' -prune -o -print | peco )"
            ;;
	$scope_favorite)
            target="$( cat ~/.dir_favorite | head -n $((LINES - 3)) | peco )"
            ;;
	$scope_recent)
	    # とりあえず1行捨てるバージョンで表示
            target="$( tac ~/.dir_history | sed '1d' | awk '!a[$0]++' | head -n $((LINES - 3)) | peco )"
            ;;
	$scope_git_rep)
            target="$( ghq list | peco )"
            ;;
        *) # 上記以外
            target="$( \ls -F | peco )" # エイリアスを外して、ディレクトリは/をつけて表示
    esac

    # 3) select action
    local action_list=()
    # todo: ドットファイルがディレクトリとして認識される
    local eval_target="$(eval "echo $target")"
    if [ -d $eval_target ]; then
        action_list=(${action_list[@]} "cd")
        action_list=(${action_list[@]} "rm -rf")
        action_list=(${action_list[@]} "mv")
        action_list=(${action_list[@]} "cp")
	# 空白文字列を含む場合は""で囲う
	if [[ "$target" =~ " " ]]; then
	    target="\"${target}\""
	fi
    elif [ $scope = $scope_git_rep ]; then
        action_list=(${action_list[@]} "cd")
        action_list=(${action_list[@]} "open with browser")
    else
        local action_list=(vi mv rm cp ls cat less open)
    fi

    local action="$(for e in ${action_list[@]}; do echo $e; done | peco)"

    if [ $scope = $scope_git_rep ]; then
        if [ $action = "cd" ]; then
	    local ghq_root="$( cygpath `ghq root` )" # スラッシュ表記に変更
	    target=${ghq_root}/${target}
	elif [ $action = "open with browser" ]; then
	    # http://qiita.com/itkrt2y/items/0671d1f48e66f21241e2
	    target="$( echo $target | cut -d "/" -f 2,3 )"
	    action="hub browse"
        fi
    fi

    # 4) select option target

    # 5) finalize
    local cmd="${action} ${target}"
    IFS=$IFS_BACKUP
    READLINE_LINE="$cmd"
    READLINE_POINT=${#cmd}
}
bind -x '"\C-j": pecorian' # vimmerならjでしょ

# peco
_replace_by_history() {
    local l=$(HISTTIMEFORMAT= history | tac | sed -e 's/^\s*[0-9]\+\s\+//' | peco --query "$READLINE_LINE")
    READLINE_LINE="$l"
    READLINE_POINT=${#l}
}
bind -x '"\C-r": _replace_by_history'

# peco
_peco_cd_by_history_log() {
    # カレントディレクトリと、ログライフの最終行が一致するときは最終行を表示しない(=初回起動時のみ表示)
    # todo: 場合分けせずに.dir_historyからカレントディレクトリを削除したものをpecoの対象にすればいいだけ
    if [[ `pwd` =  `tail -1 ~/.dir_history` ]] ; then
        # テキストの最後の行だけ削除したい(sed '$d'):http://qiita.com/richmikan@github/items/4317efffdfd57dc24cf7
        # ソートしないで重行削除する(awk '!a[$0]++')
	# http://qiita.com/arcizan/items/9cf19cd982fa65f87546
        local dir="$( tac ~/.dir_history | sed '1d' | awk '!a[$0]++' | head -n $((LINES - 3)) | peco )"
    else
        local dir="$( tac ~/.dir_history | awk '!a[$0]++' | head -n $((LINES - 3)) | peco )"
    fi
    if [ ! -z "$dir" ] ; then
        # ここではcdしない。表示後にエンターして明示的に移動。その方が履歴にも残るし。
	local l="cd $dir"
    	READLINE_LINE="$l"
    	READLINE_POINT=${#l}
    fi
}
bind -x '"\C-h": _peco_cd_by_history_log'

